// 
// 2024.07.14
//Hao Han Kao
// I declare that this submission is the result of my own work and I only copied
// the code that my professor provided to complete my workshops and assignments.
// This submitted piece of work has not been shared with any other student or
// 3rd party content provider.
STL Functions Used
In this workshop, I used several STL functions to manage the collection of BakedGood objects:

std::copy_if: Used to filter and copy elements that match a condition. For example, in the outOfStock function, it copies items that are out of stock:


std::copy_if(m_goods.begin(), m_goods.end(), std::back_inserter(result), [&type](const BakedGood& good) {
    return good.m_stock == 0 && good.m_type == type;
});
std::copy_if is great for filtering.

std::accumulate: Used to sum values, like total stock and price:

int stockSum = std::accumulate(m_goods.begin(), m_goods.end(), 0, [](int total, BakedGood current) {
    return total + current.m_stock;
});
double priceSum = std::accumulate(m_goods.begin(), m_goods.end(), 0.0, [](double total, BakedGood current) {
    return total + current.m_price;
});
std::accumulate is perfect for summing elements.

std::sort: Used to sort the collection based on different fields:


std::sort(m_goods.begin(), m_goods.end(), [&field](BakedGood a, BakedGood b) {
    if (field == "Description") {
        return a.m_description < b.m_description;
    } else if (field == "Shelf") {
        return a.m_shelfLife < b.m_shelfLife;
    } else if (field == "Stock") {
        return a.m_stock < b.m_stock;
    } else if (field == "Price") {
        return a.m_price < b.m_price;
    } else {
        throw std::invalid_argument("Invalid field name for sorting");
    }
});
std::sort is efficient and flexible for sorting.

std::for_each: Used to perform an action on each element:


std::for_each(m_goods.begin(), m_goods.end(), [&os](BakedGood good) {
    os << good << std::endl;
});
std::for_each is good for applying actions to all elements.

std::find_if: Used to find the first element that matches a condition:

auto it = std::find_if(m_goods.begin(), m_goods.end(), [&description, &type](BakedGood good) {
    return good.m_description == description && good.m_type == type && good.m_stock > 0;
});
std::find_if is useful for searching elements based on conditions.

std::merge: Used to combine two sorted ranges:


std::merge(backery1.begin(), backery1.end(), backery2.begin(), backery2.end(), std::back_inserter(combined), [](const BakedGood& a, const BakedGood& b) {
    return a.m_price < b.m_price;
});
std::merge is helpful for combining sorted collections.

Advantages of Using STL Algorithms
Using STL algorithms has several benefits:

Readability and Maintainability: STL algorithms are easier to read and understand than manual loops.
Efficiency: STL algorithms are optimized for performance.
Reduced Errors: Using STL algorithms reduces the chance of bugs compared to manual loops.
Vector vs. List in sortBakery
For the sortBakery function, using a std::vector versus a std::list is different. std::sort needs random access iterators, which std::vector has but std::list does not. For a std::list, I used its sort member function:


result.sort([](const BakedGood& a, const BakedGood& b) {
    return a.m_price < b.m_price;
});
This is important because std::list's sort is slower than std::sort on a std::vector.

Challenges and Solutions
One challenge was using STL algorithms without manual loops. Initially, I found it hard not to use traditional loops. I reviewed STL documentation to learn the algorithms and their uses. Another issue was sorting a std::list with std::sort, which needed the sort member function of std::list.

This workshop improved my understanding of STL algorithms, making my code more efficient and maintainable. It helped solidify my skills in modern C++ programming practices.






